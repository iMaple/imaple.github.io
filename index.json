{"categories":[{"link":"https://blog.imaple.net/categories/%E5%A4%87%E5%BF%98/","name":"备忘","slug":"备忘"},{"link":"https://blog.imaple.net/categories/%E6%8A%80%E6%9C%AF/","name":"技术","slug":"技术"},{"link":"https://blog.imaple.net/categories/%E6%97%A5%E5%B8%B8/","name":"日常","slug":"日常"},{"link":"https://blog.imaple.net/categories/%E6%B8%B8%E6%88%8F/","name":"游戏","slug":"游戏"},{"link":"https://blog.imaple.net/categories/%E7%AE%97%E6%B3%95/","name":"算法","slug":"算法"},{"link":"https://blog.imaple.net/categories/%E9%83%A8%E7%BD%B2/","name":"部署","slug":"部署"}],"pages":[],"posts":[{"link":"https://blog.imaple.net/posts/auto_hugo/","text":"利用 Github Action 部署 Hugo 博客，以达到 写文章 -\u0026gt; git push -\u0026gt; 自动部署 -\u0026gt; 生效 的效果。\n开始之前，建议先看看这篇文章：\n利用 GitHub Action 实现 SSL 证书的自动续签\n里面提到了一些 Github Action 的基础使用说明，一些简单的东西本文不再重复。\n现在开始，从头开始部署我们的博客。\n创建站点：\n1 2 3 $ hugo new site blog $ cd blog $ git init 加载主题：\n1 2 $ git submodule add some_theme_url themes/theme_name $ cp -r themes/theme_name/exampleSite/* . 建议将主题作为博客的子模块引入。这一步省去了主题的相关配置过程，请自行查阅相关主题文档。配置好主题后，再继续之后的步骤。\n新建文章：\n1 $ hugo new posts/hello.md 添加 .gitignore 文件并创建一个 commit：\n1 $ vim .gitignore 内容为：\n1 2 3 .DS_Store public/ 然后提交。\n1 2 $ git add . $ git commit -m \u0026#34;init site\u0026#34; 在 Github 上创建名为 blog 的私有仓库，创建一个 PERSONAL_TOKEN 并添加到该仓库的 Secrets 中。\n关于创建 Personal access token：点击这里，填入 token name，如 Github Workflows。scpoes 的话，只需要选择 repo 即可。点击 Generate token，然后记下页面上显示的 token，并作为 PERSONAL_TOKEN 填入仓库的 Secrets 中。\n然后将本地站点文件推送到远端。\n1 2 $ git remote add origin git@github.com:Your_name/blog.git $ git push --set-upstream origin main 创建名为 your_github_name.github.io 的公共仓库。\n在 blog 仓库里创建 Github Action。来一份配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 name: CI on: push: branches: - main jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: token: ${{ secrets.PERSONAL_TOKEN }} submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: Your_Github_Name/your_github_name.github.io publish_branch: gh-pages publish_dir: ./public force_orphan: true allow_empty_commit: true cname: blog.example.com user_name: \u0026#39;github-actions[bot]\u0026#39; user_email: \u0026#39;github-actions[bot]@users.noreply.github.com\u0026#39; full_commit_message: ${{ github.event.head_commit.message }} 简单说下配置中的几个步骤：\ncheckout 站点文件。这里配置了 submodules: true，会同时检出作为子模块的博客主题。如果你没有将博客主题作为站点子模块的话，还要写一个 checkout 主题的步骤。\n安装 Hugo。\n构建站点静态文件。\n部署站点静态文件。这部分说的是：\n将 public 目录下的文件部署到 your_github_name.github.io 仓库的 gh-pages 分支上；同时生成内容为 blog.example.com 的 CNAME 文件；即使 blog 仓库进行了空提交，也要执行部署任务；每次部署都清空 your_github_name.github.io 仓库之前的部署记录（commit 记录）。\n填写 Action 文件的文件名，点击 Start commit，输入 commit message 与 user email （可选），点击 Commit new file。\n现在站点正在自动构建，构建过程可以在 Action 页查看。构建完成后，即可打开 https://blog.example.com 查看效果。\n以上。\n","title":"利用 GitHub Action 自动部署博客"},{"link":"https://blog.imaple.net/posts/deploy_kms/","text":"使用 KMS Server 激活 Windows 和 Office。\n搭建 略\nps. 别问，问就是不知道。\n激活 GVLK 是用于 KMS 激活的密钥。如果想使用 KMS 激活，必须先将软件的 KEY 替换为对应版本的 GVLK。\nWindows GVLK\n激活命令:\n1 2 slmgr /skms 192.168.1.1:1688 #设置KMS服务器与端口 slmgr /ato #立即激活 Windows 其它命令:\n1 2 3 4 5 6 7 slmgr /dli #操作系统版本、部分产品密钥、许可证状态 slmgr /dlv #最为详尽的激活信息，包括：激活ID、安装ID、激活截止日期 slmgr /xpr #是否激活 slmgr /ckms #清除所使用KMS服务器信息 winver #显示操作系统版本 slmgr /upk #卸载产品密钥 slmgr /ipk XXXXX-XXXXX-XXXXX-XXXXX-XXXXX #安装产品密钥 Office GVLK\n激活命令:\n1 2 3 4 cd \u0026#34;C:\\Program Files\\Microsoft Office\\Office16\u0026#34; cscript ospp.vbs /sethst:192.168.1.1 #注册kms服务器地址 cscript ospp.vbs /setprt:1688 #注册kms服务器端口 cscript ospp.vbs /act #立即激活当前安装的Office 其它命令:\n1 2 3 4 cscript ospp.vbs /dstatus #显示当前已安装产品密钥的许可证信息 cscript ospp.vbs /unpkey:xxxxx #卸载已安装的产品密钥。后面的数字是密钥的最后5位数 cscript ospp.vbs /inpkey:XXXXX-XXXXX-XXXXX-XXXXX-XXXXX #安装、替换现有的产品密钥 cscript ospp.vbs /remhst #删除KMS主机名 ","title":"关于 Kms 服务器"},{"link":"https://blog.imaple.net/posts/auto_acme/","text":"利用 Github Action 来对免费的 Let\u0026rsquo;s Encrypt 证书进行自动续签。\n注：签发工具使用 acme.sh，签发模式为 DNS API；域名的 DNS provider 为 Cloudflare。\n新建仓库 auto-acme。（仓库名称随意，最好是私人仓库。）\n顺便一提：\n2020年10月1日起， 新创建的存储库将默认为 main。1\n添加 action 脚本中所需要的 Secrets 信息。\n包括 DNS API 所需要的验证信息，以及如果需要发送附件邮件的话，还需要一套拥有 smtp 功能的电子邮箱和密码。\n创建 Github Action。\n然后将下面的配置文件复制到网页上的编辑器内。\n配置文件内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 name: CI on: schedule: - cron: \u0026#34;0 2 1 * *\u0026#34; push: branches: - main jobs: build: runs-on: ubuntu-latest steps: - name: Install acme.sh run: | curl https://get.acme.sh | sh - name: Issue Certificates env: ACME: /home/runner/.acme.sh/acme.sh CF_Account_ID: ${{ secrets.CF_ACCOUNT_ID }} CF_Token: ${{ secrets.CF_TOKEN }} run: | mkdir -p ./ssl/example.com $ACME --issue --dns dns_cf -d example.com -d \u0026#39;*.example.com\u0026#39; -k ec-256 $ACME --installcert --ecc -d example.com -d \u0026#39;*.example.com\u0026#39; --ca-file ./ssl/example.com/chain.pem --cert-file ./ssl/example.com/cert.pem --key-file ./ssl/example.com/key.pem --fullchain-file ./ssl/example.com/fullchain.pem zip -r ssl.zip ssl - name: Get current date id: date run: echo \u0026#34;::set-output name=date::$(date +\u0026#39;%Y-%m-%d\u0026#39;)\u0026#34; - name: Create Release id: create_release uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: v${{ steps.date.outputs.date }} release_name: ${{ steps.date.outputs.date }} body: | Renew certificate files at ${{ steps.date.outputs.date }} draft: false prerelease: false - name: Upload Release Asset id: upload_release_asset uses: actions/upload-release-asset@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: upload_url: ${{ steps.create_release.outputs.upload_url }} asset_path: ./ssl.zip asset_name: ssl.zip asset_content_type: application/zip - name: Send Email uses: dawidd6/action-send-mail@v2.2.0 with: server_address: smtp.exmail.qq.com server_port: 465 username: ${{ secrets.MAIL_USERNAME }} password: ${{ secrets.MAIL_PASSWORD }} subject: Auto ACME body: Renew certificate files is complete! Download on ${{ steps.upload_release_asset.outputs.browser_download_url }}. to: admin@example.com from: GitHub Workflow attachments: ./ssl.zip 简单说下配置内容，有关 Github Action 详细信息，可查阅官方文档。首先：\n1 2 3 4 5 6 on: schedule: - cron: \u0026#34;0 2 1 * *\u0026#34; push: branches: - main 此部分配置该 Action 什么时候运行。这里配置了两个触发器，包括一个 schedule，意为在每月 1 号的 UTC 时间 02:00 运行 Action；还有一个 push，意为当对 main 分支执行 push 操作时运行 Action。然后：\n1 2 3 4 5 jobs: build: runs-on: ubuntu-latest steps: # other... 此部分说明该 workflow 包含了一个 叫做 build 的 job，该 job 将在 ubuntu 的最新发型版上工作，并包含了如下的步骤：\n安装 acme.sh。 使用 acme.sh 签发证书。此部分将 Secrets 中的 CF_ACCOUNT_ID 与 CF_TOKEN 加载到环境变量中，供 acme.sh 使用。（ps. 这里签发的是 ECC 证书） 获取现在的日期，给后面 Release body 用。 创建一个 Release。 给上面创建的 Release 上传文件，也就是打包好的证书文件。 给指定邮箱发送一封包含附件的电子邮件。（不需要的话，这部分可以直接删掉） 接着，填写 Action 文件的文件名，点击 Start commit，输入 commit message 与 user email （可选），点击 Commit new file。\n不出意外的话，应该会看到类似的界面：\n当 workflow 执行成功时（绿色对勾），到项目的 Release 页应该会看到\n以上。\nps. 私有仓库的 Github Action 每月有 2000 分钟免费计划，点击查看你的剩余额度。鉴于每月只构建一次，每次也就使用 1~2 分钟，所以完全够用。\nRenaming the default branch from master\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","title":"利用 GitHub Action 自动续签 SSL 证书"},{"link":"https://blog.imaple.net/posts/fix_githubusercontent/","text":"当使用一些脚本时，如果脚本中引用了 github 上的内容，由于众所周知的原因，可能会遇到各种各样的错误。例如：\ncurl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused\n遇到该类问题可以试试通过修改 hosts 文件的方法解决。\n获取真实 IP 地址 通过 https://www.ipaddress.com 输入 raw.githubusercontent.com 查询真实 IP 地址。\n由图可得 IP 地址为 199.232.68.133 。\n修改 hosts 文件 Windows，hosts 文件位于 C:\\Windows\\System32\\drivers\\etc 文件夹下\n写入此文件需要系统管理员权限，所以需要以管理员身份打开编辑器来编辑此文件。或者可以把这个文件拷贝到桌面，编辑完了再拷贝回去（需要系统用户账户具有管理员权限）。\n在 hosts 文件的最后一行添加以下内容，保存即可。\n1 199.232.68.133 raw.githubusercontent.com Linux or macOS，hosts 文件位于 /etc/hosts\n编辑 hosts 文件，\n1 $ sudo vim /etc/hosts 同样，在最后一行添加以下内容，保存即可。\n1 199.232.68.133 raw.githubusercontent.com 最后 愿我们能在更开放的平行世界里相遇\n以上。\n","title":"解决 raw.githubusercontent.com 无法访问"},{"link":"https://blog.imaple.net/posts/algorithm_sort/","text":"排序算法是《数据结构与算法》中最基本的算法之一。\n排序算法可以分为内部排序和外部排序，内部排序是指数据记录在内存中进行排序，而外部排序是指因排序的数据量很大，一次不能在内存种中容纳全部的排序记录，因而在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。\n通过比较元素的大小来决定元素间相对次序的排序也称为比较类排序，如经典的插入排序。由于这类排序时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。而非比较类排序则可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序，如计数排序。\n冒泡排序 (Bubble Sort) 冒泡排序是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n算法描述 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 重复步骤 1~3，直到排序完成。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 function bubbleSort(arr) { const len = arr.length; for (let i = 0; i \u0026lt; len - 1; i++) { for (let j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]; } } } return arr; } 复杂度分析 时间复杂度最坏的情况是反序序列，要比较 n(n-1)/2 次，时间复杂度为 O(n^2)，最好的情况是正序，只进行 (n-1) 次比较，不需要移动，时间复杂度为 O(n)，而平均的时间复杂度为 O(n^2)。冒泡排序是一种稳定的排序算法，元素较少时效率比较高。\n选择排序 (Selection-sort) 选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n算法描述 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第 2 步，直到所有元素均排序完毕。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function selectionSort(arr) { const len = arr.length; let minIndex; for (let i = 0; i \u0026lt; len - 1; i++) { minIndex = i; for (let j = i + 1; j \u0026lt; len; j++) { if (arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } return arr; } 复杂度分析 表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n^2) 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n插入排序 (Insertion Sort) 插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n插入排序和冒泡排序一样，有一种优化算法，叫做拆半插入。\n算法描述 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function insertionSort(arr) { const len = arr.length; let preIndex, current; for (let i = 1; i \u0026lt; len; i++) { preIndex = i - 1; current = arr[i]; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; arr[preIndex] \u0026gt; current) { arr[preIndex + 1] = arr[preIndex]; preIndex--; } arr[preIndex + 1] = current; } return arr; } 复杂度分析 插入排序的时间复杂度最好的情况是已经是正序的序列，只需比较 (n-1) 次，时间复杂度为 O(n)，最坏的情况是倒序的序列，要比较 n(n-1)/2 次，时间复杂度为 O(n^2)，平均的话要比较时间复杂度为 O(n^2)。插入排序是一种稳定的排序方法，排序元素比较少的时候很好，大量元素便会效率低下。\n希尔排序 (Shell Sort) 希尔排序也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录\u0026quot;基本有序\u0026quot;时，再对全体记录进行依次直接插入排序。\n算法描述 选择一个增量序列 t1, t2, …, tk，其中 ti \u0026gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 例如：\n动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function shellSort(arr) { const len = arr.length; let preIndex, current; for (let gap = Math.floor(len / 2); gap \u0026gt; 0; gap = Math.floor(gap / 2)) { for (let i = gap; i \u0026lt; len; i++) { preIndex = i - gap; current = arr[i]; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; arr[preIndex] \u0026gt; current) { arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; } arr[preIndex + gap] = current; } } return arr; } 复杂度分析 希尔排序的时间复杂度最好的情况是已经是正序的序列，只需比较 (n-1) 次，时间复杂度为 O(n)，最坏的情况是倒序的序列，时间复杂度为 O(nlogn)，平均时间复杂度为 O(nlogn)。\n希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比 O(n^2) 好一些。\n归并排序 (Merge Sort) 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。\n算法描述 把长度为 n 的输入序列分成两个长度为 n/2 的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function mergeSort(arr) { const len = arr.length; if (len \u0026lt; 2) { return arr; } const middle = Math.floor(len / 2); const left = arr.slice(0, middle); const right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { const result = []; while (left.length \u0026amp;\u0026amp; right.length) { if (left[0] \u0026lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) { result.push(left.shift()); } while (right.length) { result.push(right.shift()); } return result; } 复杂度分析 归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。\n快速排序 (Quick Sort) 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n算法描述 从数列中挑出一个元素，称为 “基准” (pivot); 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作； 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function quickSort(arr, left, right) { const len = arr.length; left = typeof left == \u0026#39;number\u0026#39; ? left : 0; right = typeof right == \u0026#39;number\u0026#39; ? right : len - 1; if (left \u0026lt; right) { const pivot_pos = partition(arr, left, right); quickSort(arr, left, pivot_pos - 1); quickSort(arr, pivot_pos + 1, right); } return arr; } function partition(arr, left, right) { const pivot = arr[left]; while (left \u0026lt; right) { for (; left \u0026lt; right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot; --right) {} arr[left] = arr[right] for (; left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot; ++left) {} arr[right] = arr[left] } arr[left] = pivot; return left; } 复杂度分析 相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。\n当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O(n^2)，比如说顺序数列的快排。但它的平均时间复杂度是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\n堆排序 (Heap Sort) 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。\n算法描述 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆； 将堆顶元素与末尾元素交换，将最大元素\u0026quot;沉\u0026quot;到数组末端； 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 let len; function heapify(arr, i) { const left = 2 * i + 1; const right = 2 * i + 2; let largest = i; if (left \u0026lt; len \u0026amp;\u0026amp; arr[left] \u0026gt; arr[largest]) { largest = left; } if (right \u0026lt; len \u0026amp;\u0026amp; arr[right] \u0026gt; arr[largest]) { largest = right; } if (largest !== i) { [arr[largest], arr[i]] = [arr[i], arr[largest]]; heapify(arr, largest); } } function heapSort(arr) { len = arr.length; for (let i = Math.floor(len / 2); i \u0026gt;= 0; i--) { heapify(arr, i); } for (let i = len - 1; i \u0026gt; 0; i--) { [arr[0], arr[i]] = [arr[i], arr[0]]; len--; heapify(arr, 0); } return arr; } 复杂度分析 构建初始堆经推导复杂度为 O(n)，在交换并重建堆的过程中，需交换 n-1 次，而重建堆的过程中，根据完全二叉树的性质，[log(n-1), log(n-2), ..., 1] 逐步递减，近似为 nlogn。所以堆排序时间复杂度一般认为就是 O(nlogn) 级。\n计数排序 (Counting Sort) 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n算法描述 统计数组中每个值为 i 的元素出现的次数，存入数组 bucket 的第 i 项； 对所有的计数累加； 反向填充目标数组。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function countSort(arr) { const bucket = [] for (let i = 0; i \u0026lt; arr.length; i++) { const num = arr[i] bucket[num] \u0026gt;= 1 ? bucket[num]++ : (bucket[num] = 1); } let index = 0; for (let i = 0; i \u0026lt; bucket.length; i++) { while (bucket[i] \u0026gt; 0) { arr[index++] = i; bucket[i]--; } } return arr } 复杂度分析 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0~k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。\n桶排序 (Bucket Sort) 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序。\n为了使桶排序更加高效，我们需要做到这两点：\n在额外空间充足的情况下，尽量增大桶的数量； 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\n算法描述 设置一个定量的数组当作空桶子。 寻访序列，并且把项目一个一个放到对应的桶子去。 对每个不是空的桶子进行排序。 从不是空的桶子里把项目再放回原来的序列中。 示意图 元素分布在桶中：\n然后，元素在每个桶中排序：\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function bucketSort(arr, num = 10) { function swap(arr, i, j) { const temp = arr[i] arr[i] = arr[j] arr[j] = temp } const len = arr.length const max = Math.max(...arr) const min = Math.min(...arr) const buckets = [] const bucketsSize = Math.floor((max - min) / num) + 1 for (let i = 0; i \u0026lt; len; i++) { const index = Math.floor((arr[i] - min) / bucketsSize) if (!buckets[index]) { buckets[index] = [] } buckets[index].push(arr[i]) for (let l = buckets[index].length; l \u0026gt; 0; l--) { if (buckets[index][l] \u0026lt; buckets[index][l - 1]) { swap(buckets[index], l, l - 1) } } } let wrapBuckets = [] for (let i = 0; i \u0026lt; buckets.length; i++) { if (buckets[i]) { wrapBuckets = wrapBuckets.concat(buckets[i]) } } return wrapBuckets } 复杂度分析 桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\n基数排序 (Radix Sort) 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。\n算法描述 取得数组中的最大数，并取得位数； arr 为原始数组，从最低位开始取每个位组成 radix 数组； 对 radix 进行计数排序（利用计数排序适用于小范围数的特点）。 动图演示 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function radixSort(arr) { const max = Math.max(...arr) const counter = []; for (let i = 0, mod = 10, dev = 1; i \u0026lt; max; i++, dev *= 10, mod *= 10) { for (let j = 0; j \u0026lt; arr.length; j++) { const bucket = Math.floor((arr[j] % mod) / dev); if (counter[bucket] == null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } let pos = 0; for (let j = 0; j \u0026lt; counter.length; j++) { let value = null; if (counter[j] != null) { while ((value = counter[j].shift()) != null) { arr[pos++] = value; } } } } return arr; } 复杂度分析 基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n) 的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n) 的时间复杂度。假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n，因此基本上还是线性级别的。\n基数排序的空间复杂度为 O(n+k)，其中 k 为桶的数量。一般来说 n\u0026gt;\u0026gt;k，因此额外空间需要大概 n 个左右。\n参考 十大经典排序算法\n十大经典排序算法（动图演示）\n排序：希尔排序（算法）\n算法 3：最常用的排序——快速排序\n图解排序算法(三)之堆排序\n","title":"常见的十个排序算法"},{"link":"https://blog.imaple.net/posts/deploy_teamspeak3/","text":"搭建 Teamspeak3 服务器。（ps: 最好直接上 Docker）\n环境：Ubuntu 18.04。\n新建 teamspeak 用户：\n1 2 3 # adduser --disabled-login teamspeak # su teamspeak $ cd ~ 前往下载页面查看最新服务端版本，并替换之后命令中的版本号。\n下载、复制并解压 TS3 服务端文件：\n1 2 3 4 $ wget https://files.teamspeak-services.com/releases/server/3.10.1/teamspeak3-server_linux_amd64-3.10.1.tar.bz2 $ tar -xjvf teamspeak3-server_linux_amd64-3.10.1.tar.bz2 $ mv teamspeak3-server_linux_amd64 teamspeak3-server $ rm -rf teamspeak3-server_linux_amd64-3.10.1.tar.bz2 同意许可条款：\n1 2 $ cd teamspeak3-server $ touch .ts3server_license_accepted 建立启动文件：\n1 2 $ su root # vim /lib/systemd/system/teamspeak3.service 内容为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Unit] Description=Teamspeak, The most superior online voice communication solution. Wants=network-online.target After=syslog.target network.target network-online.target [Service] WorkingDirectory=/home/teamspeak/teamspeak3-server/ User=teamspeak Group=teamspeak Type=forking ExecStart=/home/teamspeak/teamspeak3-server/ts3server_startscript.sh start ExecStop=/home/teamspeak/teamspeak3-server/ts3server_startscript.sh stop PIDFile=/home/teamspeak/teamspeak3-server/ts3server.pid RestartSec=15 Restart=always [Install] WantedBy=multi-user.target 启动并查看状态：\n1 2 $ systemctl start teamspeak3 $ systemctl status teamspeak3 以上。\n","title":"搭建 Teamspeak3 服务器"},{"link":"https://blog.imaple.net/posts/deploy_mail_server/","text":"使用 Postfix, Dovecot, SQLite 搭建邮件服务器。\n名次解释：\nFQDN：完全限定域名。完整域名由主机名称与母域名两部分所组成。 rDNS：反向 DNS 解析。查询 DNS 来确定与 IP 地址关联的域名。 约定：\n本文中所用域名为：example.com，FQDN 为 mail.example.com。 基本的准备 依次完成如下工作：\n打开服务器相关端口： 25 (SMTP) 465 (SMTPS) 143 (IMAP) 993 (IMAPS) 设置一条 A 记录，使你的 FQDN 指向服务器 ip。 给你的域名设置一条 MX 记录。 给你的服务器设置反向 DNS 解析，使你的服务器 ip 指向你的 FQDN。 设置服务器主机名 (hostname) 为你的 FQDN。 获取域名 SSL 证书 使用 acme.sh 签发即可。下面这篇文章可能会有一点帮助。\n利用 GitHub Action 实现 SSL 证书的自动续签\n将证书文件放置在如下位置：\n/opt/ssl_certificate/fullchain.pem 和 /opt/ssl_certificate/key.pem\n安装软件包 包括 Postfix、Dovecot、SQLite3 以及一些辅助性的软件。安装完成后，备份配置文件。\n1 2 3 4 5 # apt install postfix postfix-sqlite -y # apt install dovecot-imapd dovecot-lmtpd dovecot-sqlite -y # apt install sqlite3 -y # apt install postgrey postfix-policyd-spf-python opendkim opendkim-tools fail2ban -y # tar -czvf backup.tar.gz /etc/postfix /etc/dovecot /etc/opendkim.conf 顺便新建用户与用户组 vmail。\n1 2 3 # groupadd -g 5000 vmail # useradd -g vmail -u 5000 vmail -d /var/mail -s /sbin/nologin # chown -R vmail:vmail /var/mail 设置 DKIM记录并配置 opendkim 服务 编辑配置文件。\n1 # vim /etc/opendkim.conf 在配置文件中找到如下几行，取消这几行的注释，并将 simple 改为 relaxed/simple。\n1 2 3 Canonicalization simple Mode sv SubDomains no 接着找到这一行 (#ADSPAction continue)，并将下面的内容添加到这行后面。如果没有找到这一行，只需要将下面的内容添加到这一行 (SubDomains no) 后面即可。\n1 2 3 4 5 AutoRestart yes AutoRestartRate 10/1M Background yes DNSTimeout 5 SignatureAlgorithm rsa-sha256 将如下内容添加到文件末尾。在 Ubuntu 18.04 上，UserID 已经设置为 opendkim，无需重复添加。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #OpenDKIM user # Remember to add user postfix to group opendkim UserID opendkim # Map domains in From addresses to keys used to sign messages KeyTable refile:/etc/opendkim/key.table SigningTable refile:/etc/opendkim/signing.table # Hosts to ignore when verifying signatures ExternalIgnoreList /etc/opendkim/trusted.hosts # A set of internal hosts whose mail should be signed InternalHosts /etc/opendkim/trusted.hosts 然后找到这一行：\n1 Socket local:/var/run/opendkim/opendkim.sock 把它替换为：\n1 Socket local:/var/spool/postfix/opendkim/opendkim.sock 保存文件并退出 vim。\n执行如下命令，创建所需文件夹并编辑配置文件。\n1 2 # mkdir -p /etc/opendkim/keys/example.com # vim /etc/opendkim/signing.table 写入如下内容：\n1 *@example.com default._domainkey.example.com 保存。注意上述内容中的域名要替换为你要部署的真实域名，后续不再提示。\n编辑文件。\n1 # vim /etc/opendkim/key.table 写入如下内容：\n1 default._domainkey.example.com example.com:default:/etc/opendkim/keys/example.com/default.private 保存。注意，上面的内容为一整行，而不是两行分开。\n编辑文件。\n1 # vim /etc/opendkim/trusted.hosts 写入如下内容：\n1 2 3 4 127.0.0.1 localhost *.example.com 保存。\n生成 opendkim key 并输出。\n1 2 3 # opendkim-genkey -b 2048 -d example.com -D /etc/opendkim/keys/example.com -s default -v # chown -R opendkim:opendkim /etc/opendkim # cat /etc/opendkim/keys/example.com/default.txt 将输出的 opendkim key 按如下格式设置域名的 TXT 记录。注意删除记录值中多余的双引号。\nTXT default._domainkey v=DKIM1; K=rsa; p=xxxxxx;\n使用如下命令测试是否配置成功。\n1 # opendkim-testkey -d example.com -s default -vvv 执行如下命令，使 Postfix 可以使用 opendkim 服务。\n1 2 3 4 # gpasswd -a postfix opendkim # mkdir /var/spool/postfix/opendkim # chown opendkim:postfix /var/spool/postfix/opendkim # systemctl restart opendkim 设置 SPF 记录 按如下格式设置域名的 TXT 记录。\nTXT @ v=spf1 mx ~all\n设置 DMARC 记录 按如下格式设置域名的 TXT 记录。\nTXT _dmarc v=DMARC1; p=none; pct=100; sp=none; adkim=r; aspf=r; fo=1; rua=mailto:your_another_mail@gmail.com; ruf=mailto:your_another_mail@gmail.com;\n配置拦截政策 白名单 1 # vim /etc/postfix/rbl_override 1 2 dripemail2.com OK //drip.com mlsend.com OK //mailerlite email marketing service 1 # postmap /etc/postfix/rbl_override HELO/EHLO 主机名 1 # vim /etc/postfix/helo_access 1 2 optimus-webapi-prod-2.localdomain OK va-massmail-02.rakutenmarketing.com OK 1 # postmap /etc/postfix/helo_access 灰名单 1 # vim /etc/default/postgrey 找到下面这一行：\n1 POSTGREY_OPTS=\u0026#34;--inet=10023\u0026#34; 把它改为：\n1 POSTGREY_OPTS=\u0026#34;--inet=127.0.0.1:10023 --delay=60\u0026#34; 然后重启 postgrey 服务。\n1 # systemctl restart postgrey 配置 Fail2ban 工具 fail2ban 能有效防止常见的洪水攻击。\n编辑 postfix 规则。\n1 # vim /etc/fail2ban/jail.d/postfix.conf 内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 [postfix] enabled = true logpath = %(syslog_mail)s maxretry = 3 bantime = 1h filter = postfix [postfix-flood-attack] enabled = true logpath = %(syslog_mail)s bantime = 1h filter = postfix-flood-attack port = smtp,smtps,imap,imaps,sieve 保存。然后编辑 dovecot 规则。\n1 # vim /etc/fail2ban/jail.d/dovecot.conf 内容如下：\n1 2 3 4 5 6 [dovecot] enabled = true logpath = %(syslog_mail)s maxretry = 3 bantime = 1h filter = dovecot 保存。然后编辑 postfix 过滤器。\n1 # vim /etc/fail2ban/filter.d/postfix-flood-attack.conf 内容如下：\n1 2 3 4 5 6 7 8 9 10 [INCLUDES] before = common.conf [Definition] _daemon = postfix(-\\w+)?/(?:submission/|smtps/)?smtp[ds] failregex = ^%(__prefix_line)slost connection after AUTH from \\S+\\[\u0026lt;HOST\u0026gt;\\]$ ignoreregex = [Init] journalmatch = _SYSTEMD_UNIT=postfix.service 保存。重启 fail2ban 服务。\n1 # systemctl restart fail2ban 创建数据库表 创建并调用 sqlite 数据库。\n1 # sqlite3 /etc/postfix/postfix.sqlite 调整格式化输出。\n1 2 3 sqlite\u0026gt; .header on sqlite\u0026gt; .mode column sqlite\u0026gt; .timer on 依次执行如下 SQL 语句，创建数据库表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 CREATE TABLE domains ( id INTEGER PRIMARY KEY AUTOINCREMENT, domain varchar(255) NOT NULL UNIQUE, description varchar(255) NOT NULL default \u0026#39;\u0026#39;, active tinyint(1) NOT NULL default \u0026#39;1\u0026#39; ); CREATE TABLE users ( id INTEGER PRIMARY KEY AUTOINCREMENT, username varchar(255) NOT NULL, password varchar(255) NOT NULL, domain_id INTEGER NOT NULL, quota bigint(20) NOT NULL default \u0026#39;0\u0026#39;, created datetime NOT NULL default (datetime(\u0026#39;now\u0026#39;, \u0026#39;localtime\u0026#39;)), active tinyint(1) NOT NULL default \u0026#39;1\u0026#39;, FOREIGN KEY(domain_id) REFERENCES domains(id) ); CREATE TABLE aliases ( id INTEGER PRIMARY KEY AUTOINCREMENT, domain_id int(11) NOT NULL, source varchar(255) NOT NULL, destination varchar(255) NOT NULL, active tinyint(1) NOT NULL default \u0026#39;1\u0026#39;, FOREIGN KEY(domain_id) REFERENCES domains(id) ); INSERT INTO domains (domain) VALUES (\u0026#39;example.com\u0026#39;); INSERT INTO users (username, password, domain_id) VALUES (\u0026#39;i\u0026#39;, \u0026#39;{CRYPT}$2y$05$....\u0026#39;, 1); INSERT INTO aliases (domain_id, source, destination) VALUES (1, \u0026#39;aliase@example.com\u0026#39;, \u0026#39;i@example.com\u0026#39;); 注：邮箱用户密码可暂时使用如下命令生成：\n1 # doveadm pw -p \u0026#34;passwd\u0026#34; 配置 Postfix 编辑 /etc/postfix/main.cf。\n1 # vim /etc/postfix/main.cf 替换为如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 #----- General ----- myhostname = mail.example.com myorigin = /etc/mailname mydestination = localhost relayhost = mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 mailbox_size_limit = 0 recipient_delimiter = + inet_interfaces = all inet_protocols = all mynetworks_style = host append_dot_mydomain = no readme_directory = no compatibility_level = 2 #----- SMTPD parameters ----- biff = no #delay_warning_time = 4h disable_vrfy_command = yes strict_rfc821_envelopes = yes #smtputf8_enable = no smtpd_banner = $myhostname ESMTP $mail_name (Ubuntu) smtpd_delay_reject = yes smtpd_helo_required = yes smtpd_timeout = 30s smtpd_recipient_limit = 40 #smtpd_etrn_restrictions = reject #smtpd_reject_unlisted_sender = yes #smtpd_reject_unlisted_recipient = yes #smtpd_hard_error_limit = 1 smtp_always_send_ehlo = yes smtp_helo_timeout = 15s smtp_rcpt_timeout = 15s #maximal_queue_lifetime = 1d #bounce_queue_lifetime = 1d minimal_backoff_time = 180s maximal_backoff_time = 3h #----- TLS parameters ----- smtpd_use_tls = yes smtpd_tls_auth_only = yes smtpd_tls_cert_file = /opt/ssl_certificate/fullchain.pem smtpd_tls_key_file = /opt/ssl_certificate/key.pem smtpd_tls_ciphers = high smtpd_tls_security_level = may smtpd_tls_protocols = !SSLv2, !SSLv3, !TLSv1, !TLSv1.1 smtpd_tls_mandatory_protocols = !SSLv2, !SSLv3, !TLSv1, !TLSv1.1 smtpd_tls_loglevel = 0 smtpd_tls_session_cache_database = btree:${data_directory}/smtpd_scache smtpd_tls_received_header = yes smtp_tls_security_level = may smtp_tls_protocols = !SSLv2, !SSLv3, !TLSv1, !TLSv1.1 smtp_tls_mandatory_protocols = !SSLv2, !SSLv3, !TLSv1, !TLSv1.1 smtp_tls_loglevel = 0 smtp_tls_session_cache_database = btree:${data_directory}/smtp_scache #----- SASL parameters ----- smtpd_sasl_type = dovecot smtpd_sasl_path = private/auth smtpd_sasl_auth_enable = yes smtpd_sasl_security_options = noanonymous #smtpd_sasl_local_domain = #smtpd_sasl_authenticated_header = no #broken_sasl_auth_clients = no #----- Virtual domains ----- alias_maps = hash:/etc/aliases alias_database = hash:/etc/aliases virtual_transport = lmtp:unix:private/dovecot-lmtp virtual_mailbox_domains = sqlite:/etc/postfix/sqlite_mailbox_domains.cf virtual_mailbox_maps = sqlite:/etc/postfix/sqlite_mailbox_maps.cf virtual_alias_maps = sqlite:/etc/postfix/sqlite_alias_maps.cf #virtual_uid_maps = static:5000 #virtual_gid_maps = static:5000 #----- Restrictions ----- smtpd_recipient_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_non_fqdn_recipient, reject_unknown_recipient_domain, reject_unlisted_recipient, reject_unauth_destination, reject_unauth_pipelining, check_policy_service unix:private/policyd-spf, check_policy_service inet:127.0.0.1:10023, check_client_access hash:/etc/postfix/rbl_override, reject_rhsbl_helo dbl.spamhaus.org, reject_rhsbl_reverse_client dbl.spamhaus.org, reject_rhsbl_sender dbl.spamhaus.org smtpd_sender_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_sender_login_mismatch, reject_non_fqdn_sender, reject_unknown_sender_domain, reject_unknown_reverse_client_hostname, reject_unknown_client_hostname, reject_unauth_pipelining smtpd_helo_restrictions = permit_mynetworks, permit_sasl_authenticated, check_helo_access hash:/etc/postfix/helo_access, reject_invalid_helo_hostname, reject_non_fqdn_helo_hostname, reject_unknown_helo_hostname smtpd_relay_restrictions = permit_mynetworks, permit_sasl_authenticated, defer_unauth_destination, check_helo_access hash:/etc/postfix/helo_access, reject_invalid_helo_hostname, reject_non_fqdn_helo_hostname, reject_unknown_helo_hostname smtpd_client_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_unknown_client_hostname, reject_rbl_client bl.spamcop.net, reject_rbl_client zen.spamhaus.org, reject_rbl_client blackholes.easynet.nl smtpd_data_restrictions = reject_unauth_pipelining #----- policyd-spf ----- policyd-spf_time_limit = 3600 #----- Opendkim ----- milter_default_action = accept milter_protocol = 6 smtpd_milters = local:/opendkim/opendkim.sock non_smtpd_milters = $smtpd_milters 保存。然后编辑 /etc/postfix/master.cf。\n1 # vim /etc/postfix/master.cf 取消 smtps 小节的注释，并调整为如下几行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 smtps inet n - y - - smtpd -o syslog_name=postfix/smtps -o smtpd_tls_security_level=encrypt -o smtpd_tls_wrappermode=yes -o smtpd_sasl_auth_enable=yes -o smtpd_sasl_type=dovecot -o smtpd_sasl_path=private/auth -o smtpd_sasl_security_options=noanonymous -o smtpd_sasl_local_domain=$myhostname -o smtpd_reject_unlisted_recipient=no -o smtpd_sender_login_maps=sqlite:/etc/postfix/sqlite_mailbox_maps.cf -o smtpd_sender_restrictions=reject_sender_login_mismatch -o smtpd_client_restrictions=permit_sasl_authenticated,reject -o smtpd_relay_restrictions=permit_sasl_authenticated,reject -o smtpd_recipient_restrictions=reject_non_fqdn_recipient,reject_unknown_recipient_domain,permit_mynetworks,permit_sasl_authenticated,reject -o milter_macro_daemon_name=ORIGINATING 在文件末尾添加下面几行：\n1 2 policyd-spf unix - n n - 0 spawn user=policyd-spf argv=/usr/bin/policyd-spf 保存。然后编辑 sqlite_mailbox_domains.cf\n1 # vim /etc/postfix/sqlite_mailbox_domains.cf 内容为：\n1 2 3 dbpath = /etc/postfix/postfix.sqlite query = SELECT domain FROM domains WHERE domain=\u0026#39;%s\u0026#39; result_format = %s 保存。然后编辑 sqlite_mailbox_maps.cf\n1 # vim /etc/postfix/sqlite_mailbox_maps.cf 内容为：\n1 2 3 dbpath = /etc/postfix/postfix.sqlite query = SELECT username||\u0026#39;@\u0026#39;|| FROM users INNER JOIN domains on users.domain_id=domains.id WHERE username=\u0026#39;%u\u0026#39; result_format = %s 保存。然后编辑 sqlite_alias_maps.cf\n1 # vim /etc/postfix/sqlite_alias_maps.cf 内容为：\n1 2 3 dbpath = /etc/postfix/postfix.sqlite query = SELECT destination FROM aliases WHERE source = \u0026#39;%s\u0026#39; result_format = %s 配置 Dovecot 编辑 /etc/dovecot/dovecot.conf\n将 protocols = imap lmtp 添加到 # Enable installed protocols 的后面。\n保存。然后编辑 /etc/dovecot/conf.d/10-auth.conf\n修改文件内容为如下几行：\n1 2 3 disable_plaintext_auth = yes auth_mechanisms = plain login !include auth-sql.conf.ext 保存。然后编辑 /etc/dovecot/conf.d/10-mail.conf\n修改文件内容为如下几行：\n1 2 mail_location = maildir:/var/mail/%d/%n/ mail_privileged_group = mail 保存。然后编辑 /etc/dovecot/conf.d/10-master.conf\n编辑 service auth 块为：\n1 2 3 4 5 6 7 8 9 10 11 12 service auth { unix_listener auth-userdb { mode = 0600 user = vmail group = vmail } unix_listener /var/spool/postfix/private/auth { mode = 0660 user = postfix group = postfix } } 编辑 service lmtp 块为：\n1 2 3 4 5 6 7 service lmtp { unix_listener /var/spool/postfix/private/dovecot-lmtp { mode = 0600 user = postfix group = postfix } } 编辑 service auth-worker 块为：\n1 2 3 service auth-worker { #user = vmail } 保存。然后编辑 /etc/dovecot/conf.d/10-ssl.conf\n修改文件内容为如下几行：\n1 2 3 4 ssl = required ssl_cert = \u0026lt;/opt/ssl_certificate/fullchain.pem ssl_key = \u0026lt;/opt/ssl_certificate/key.pem ssl_min_protocol = TLSv1.2 保存。然后编辑 /etc/dovecot/conf.d/auth-sql.conf.ext\n修改文件内容为如下几行：\n1 2 3 4 5 6 7 8 passdb { driver = sql args = /etc/dovecot/dovecot-sql.conf.ext } userdb { driver = static args = uid=vmail gid=vmail home=/var/mail/%d/%n } 保存。然后编辑 /etc/dovecot/dovecot-sql.conf.ext\n修改文件内容为如下几行：\n1 2 3 4 5 6 7 driver = sqlite connect = /etc/postfix/postfix.sqlite default_pass_scheme = SHA512-CRYPT password_query = \\ SELECT username, domain, password \\ FROM users INNER JOIN domains ON users.domain_id=domains.id \\ WHERE username = \u0026#39;%n\u0026#39; AND domain = \u0026#39;%d\u0026#39; 测试 Newsletters spam test\n参考 Install Dovecot IMAP server on Ubuntu \u0026amp; Enable TLS Encryption Installing Postfix on Ubuntu using SQLite ISPmail tutorials Email with Postfix, Dovecot, and MySQL Setting Up Your Own Mail Server on Ubuntu 以上。\n","title":"搭建 SMTP 邮件服务器"},{"link":"https://blog.imaple.net/posts/about_minecraft/","text":"整理一些 mincraft 生态，包括材质、模组、辅助工具。\n材质 名称 下载 备注 Minecraft HD Link 64x PureBDcraft Link 16x ~ 512x Minecraft-3D-Default Link 模组 名称 功能 下载 备注 Fabric mod loader Link Fabric API 核心依赖API Link Mod Menu 模组列表 Link VoxelMap 小地图 Link WorldEdit 创世神 Link Hwyla 指向方块信息显示 Link WorldDownloader 区块下载 Link 非 Fabric 加载 Phosphor 光照优化 Link Roughly Enough Items 物品列表, 合成表 Link Light Overlay 光照强度显示 Link Bounding Box Outline Reloaded 区域显示 Link EasierCrafting 快速合成 Link Giselbaer\u0026rsquo;s Durability Viewer 耐久度显示 Link Litematica 建筑投影 Link Temporarily Download Tweakeroo 实用工具合辑 Link Temporarily Download MiniHUD 迷你F3 Link Temporarily Download Item Scroller 快速物品交换 Link Temporarily Download MaLiLib 上四依赖 Link Temporarily Download Carpet 技术生存 Link Euclid 创世神CUI Link 工具 名称 功能 下载 备注 Amidst 种子查看 Link Chunk Base 种子查看 Link 网页 ","title":"Minecraft 相关"},{"link":"https://blog.imaple.net/posts/about_git/","text":"记录一些能用的上的有关 git 的 奇技淫巧。（不定期更新）\nstash 保存记录：\n1 $ git stash save \u0026#34;some msg\u0026#34; 或，\n1 $ git stash 查看记录：\n1 $ git stash list 查看记录内容：\n1 $ git stash show stash@{0} 恢复记录：\n1 $ git stash apply stash@{0} 或，\n1 $ git pop 删除记录：\n1 $ git stash drop stash@{0} 或，\n1 $ git stash clear 主分支名称改为 main 修改分支名称并推送到远端：\n1 2 $ git branch -m master main $ git push --set-upstream origin main 设置远端默认分支名（Github）：\n删除远端无用分支：\n1 $ git push origin :master 清除历史提交记录 利用变基操作：\n1 2 3 4 5 $ git log $ git rebase -i --root $ git add -A $ git commit -m \u0026#34;\u0026#34; $ git push origin master -f 或，新建分支并删除原主分支：\n1 2 3 4 5 6 $ git checkout --orphan new $ git add -A $ git commit -m \u0026#34;\u0026#34; $ git branch -D master $ git branch -m master $ git push origin master -f ","title":"Git 相关"},{"link":"https://blog.imaple.net/posts/first_post/","text":"这里是枫林的第一篇文与他的碎碎念。\n借用大多计算机初学者的第一个计算机程序——\u0026ldquo;Hello World\u0026quot;来表达我此时的心情。\n折腾多年，最近终于下定决心好好弄个地方来记录一些东西，同时希望能交到一些朋友。于是便选择了博客这一方式。正好临近2020年元旦，做了一些准备后便定在1月1日正式“开张”，图个好开头xd。\n大二的时候折腾过 Wordpress，弄好之后没几天便拆了。一是无心去维护它，二是它太“大”了。于是这次便将目光转向了静态博客系统。经过一番体验后选择了 hugo 这个框架（主要 hexo 文档太水了），并把 hexo 上一个不错的主题迁了过来。不过时间仓促，还有些不完善的地方，以后慢慢改吧。\n写着写着时间便跨过了24点，进入了新的一年。祝自己新年快乐！\n最后，希望自己新的一年能更进一步。共勉 : )\n以上。\n","title":"Hello World"},{"link":"https://blog.imaple.net/posts/nginx_tls/","text":"备份，参考。\n先上一份完整的配置文件：\n/etc/nginx/conf.d/http.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 server { listen 80 default_server; listen 443 ssl default_server; server_name _; # server_tokens off; include /etc/nginx/ssl/ssl.conf; return 404; } server { listen 80; listen [::]:80; server_name example.com; server_tokens off; if ($request_method !~ ^(GET|HEAD|POST)$ ) { return 444; } location / { return 301 https://$host$request_uri; } } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name example.com; include /etc/nginx/ssl/ssl.conf; location / { proxy_pass_header Server; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://127.0.0.1:8086/; } } /etc/nginx/ssl/ssl.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 server_tokens off; ssl_certificate /opt/ssl_certificate/example.com/fullchain.pem; ssl_certificate_key /opt/ssl_certificate/example.com/key.pem; ssl_dhparam /etc/nginx/ssl/dhparam.pem; ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:DHE-RSA-AES256-GCM-SHA384; ssl_ecdh_curve prime256v1; ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_session_tickets off; ssl_stapling on; ssl_stapling_verify on; resolver 8.8.8.8 valid=300s; resolver_timeout 5s; add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubDomains; preload\u0026#34;; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; # add_header X-XSS-Protection \u0026#34;1; mode=block\u0026#34;; add_header Content-Security-Policy \u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; \u0026#39;unsafe-eval\u0026#39;; style-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; https://fonts.googleapis.com; font-src \u0026#39;self\u0026#39; https://fonts.gstatic.com; img-src \u0026#39;self\u0026#39; data:; connect-src \u0026#39;self\u0026#39;\u0026#34;; 然后大概说说这都是什么东西，以及为什么要这样做。\nTODO\n","title":"Nginx 的 HTTPS 配置"}],"tags":[{"link":"https://blog.imaple.net/tags/algorithm/","name":"Algorithm","slug":"Algorithm"},{"link":"https://blog.imaple.net/tags/certificate/","name":"Certificate","slug":"Certificate"},{"link":"https://blog.imaple.net/tags/dont-ask/","name":"Don't Ask","slug":"Don't Ask"},{"link":"https://blog.imaple.net/tags/git/","name":"Git","slug":"Git"},{"link":"https://blog.imaple.net/tags/hugo/","name":"Hugo","slug":"Hugo"},{"link":"https://blog.imaple.net/tags/mail/","name":"Mail","slug":"Mail"},{"link":"https://blog.imaple.net/tags/minecraft/","name":"Minecraft","slug":"Minecraft"},{"link":"https://blog.imaple.net/tags/nginx/","name":"Nginx","slug":"Nginx"},{"link":"https://blog.imaple.net/tags/sqlite/","name":"Sqlite","slug":"Sqlite"},{"link":"https://blog.imaple.net/tags/teamspeak3/","name":"Teamspeak3","slug":"Teamspeak3"},{"link":"https://blog.imaple.net/tags/tls/","name":"TLS","slug":"TLS"},{"link":"https://blog.imaple.net/tags/workflow/","name":"Workflow","slug":"Workflow"}]}